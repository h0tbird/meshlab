#!/usr/bin/env bash

##-----------------------------------------------------------------------------
## TODO Create a cli tool that will be installed via brew and will be used to
## create the VMs and install a controller. VMs will be created by multipass
## using remote custom images pre-created with packer.
##-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# [i] Initializations
#------------------------------------------------------------------------------

# Bash strict mode
set -euo pipefail

# Change to the execution directory
cd "$(dirname "$0")"/..

# shellcheck source=/dev/null
source lib/common.sh
# shellcheck source=/dev/null
source lib/misc.sh

#------------------------------------------------------------------------------
# [i] Pull-through image cache
#------------------------------------------------------------------------------

blue "---[ Pull-through registries ]------------------------------------------"

docker start registry-docker.io 2>/dev/null || docker run -d -p 5011:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://registry-1.docker.io \
  --restart always \
  --name registry-docker.io \
  registry:2

docker start registry-quay.io 2>/dev/null || docker run -d -p 5012:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://quay.io \
  --restart always \
  --name registry-quay.io \
  registry:2

docker start registry-ghcr.io 2>/dev/null || docker run -d -p 5013:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://ghcr.io \
  --restart always \
  --name registry-ghcr.io \
  registry:2

#------------------------------------------------------------------------------
# [i] Create clusters
#------------------------------------------------------------------------------

blue "---[ Multipass VMs ]----------------------------------------------------"

MPLIST=$(multipass list)
N=$(list clusters | wc -w)

# Start the management cluster
echo "${MPLIST}" | grep "${MNGR}" | grep -q Running || {
  { multipass start "${MNGR}" 2>/dev/null || (launch_k8s "${MNGR}" "cluster") } &
  sleep 5
}

# Start all the stamp clusters
for STAMP in $(list stamps); do for CLUSTER in ${STAMPS[${STAMP}]}; do
    echo "${MPLIST}" | grep "${CLUSTER}" | grep -q Running || {
      { multipass start "${CLUSTER}" 2>/dev/null || (launch_k8s "${CLUSTER}" "${STAMP}") } &
      sleep 5
    }
done; done; wait

# Get all the IPs
declare -A IP
for CLUSTER in $(list clusters all); do
    IP[${CLUSTER}]=$(multipass info "${CLUSTER}" | grep IPv4 | awk '{print $2}')
    echo "${CLUSTER} = ${IP[${CLUSTER}]}"
done

#------------------------------------------------------------------------------
# [i] Setup KUBECONFIG
#------------------------------------------------------------------------------

blue "---[ KUBECONFIG ]-------------------------------------------------------"

K8SCFG=~/.kube/config
for CLUSTER in $(list clusters all); do
  K8SCFG=${K8SCFG}:./tmp/${CLUSTER}/config
done

KUBECONFIG=${K8SCFG} \
kubectl config view --flatten > ./tmp/config && cp ./tmp/config ~/.kube/config

function k0 {
  kubectl --context "${MNGR}" "${@}"
}

echo "${K8SCFG}" | tr ':' '\n'

#------------------------------------------------------------------------------
# [i] Wait for all the clusters to be ready
#------------------------------------------------------------------------------

blue "---[ Wait for clusters ]------------------------------------------------"

for CLUSTER in $(list clusters all); do
  until kubectl --context "${CLUSTER}" wait --for=condition=Ready pods --all -A 2>/dev/null; do
    sleep 2
  done &
done; wait

#------------------------------------------------------------------------------
# [i] Setup CoreDNS server DNS entries for demo.lab
#------------------------------------------------------------------------------

blue "---[ CoreDNS ]----------------------------------------------------------"

for CLUSTER in $(list clusters); do

kubectl --context "${CLUSTER}" -n kube-system create cm coredns-custom \
--dry-run=client -o yaml --from-literal=demo.server="demo.lab {
  hosts {
    ttl 60
    ${IP[${MNGR}]} vault.demo.lab
    fallthrough
  }
}" | kubectl --context "${CLUSTER}" -n kube-system apply -f -

# Restart otherwise it takes a while to pick up the new config
kubectl --context "${CLUSTER}" -n kube-system rollout restart deployment coredns

done

#------------------------------------------------------------------------------
# [i] Setup ArgoCD
#------------------------------------------------------------------------------

blue "---[ ArgoCD ]-----------------------------------------------------------"

# Install ArgoCD
helm upgrade --install -n argocd --create-namespace --wait --timeout 5m \
argocd oci://ghcr.io/argoproj/argo-helm/argo-cd --version 6.9.0 \
--set 'server.service.type=LoadBalancer' \
-f - << EOF | grep -E '^NAME|^LAST|^STATUS|^REVISION|^TEST'
configs:
  cm:
    resource.customizations.ignoreDifferences.admissionregistration.k8s.io_MutatingWebhookConfiguration: |
      jqPathExpressions:
      - '.webhooks[]?.clientConfig.caBundle'
EOF

# Get the password
ARGOCD_PASS=$(
  k0 -n argocd \
  get secret argocd-initial-admin-secret \
  -o jsonpath='{.data.password}' | base64 -d
)

echo
echo "ArgoCD WebUI: https://${IP[${MNGR}]}"
echo "ArgoCD User: admin"
echo "ArgoCD Pass: ${ARGOCD_PASS}"

#------------------------------------------------------------------------------
# [i] Register clusters to ArgoCD
#------------------------------------------------------------------------------

blue "---[ Register clusters to ArgoCD ]--------------------------------------"

# Check if the ArgoCD context exists
argocd context "${MNGR}" 2> /dev/null || {

  # Login to ArgoCD
  argocd login "${IP[${MNGR}]}" \
    --insecure \
    --name "${MNGR}" \
    --username admin \
    --password "${ARGOCD_PASS}"

  # Add clusters with labels
  for STAMP in $(list stamps); do for CLUSTER in ${STAMPS[${STAMP}]}; do
    argocd cluster add -y "${CLUSTER}" --label name="${CLUSTER}" --label stamp="${STAMP}"
  done; done
}

#------------------------------------------------------------------------------
# [i] Install all the ApplicationSets
#------------------------------------------------------------------------------

blue "---[ ApplicationSets ]-------------------------------------------------"

helm template ./charts/prometheus | k0 apply -f -
helm template ./charts/vault | k0 apply -f -
helm template ./charts/cert-manager | k0 apply -f -
helm template ./charts/istio | k0 apply -f -

#------------------------------------------------------------------------------
# [i] Setup ArgoWF
#------------------------------------------------------------------------------

blue "---[ ArgoWF ]-----------------------------------------------------------"

# Install Argo Workflows
helm upgrade --install -n argowf --create-namespace --wait --timeout 5m \
  argo-workflows argo/argo-workflows --version 0.41.4 \
  --set 'server.serviceType=LoadBalancer' \
  --set 'server.authModes={server}' \
  --set 'workflow.serviceAccount.create=true' \
  --set 'workflow.serviceAccount.name=argo-workflow' \
  --set 'workflow.rbac.create=true' \
  --set 'controller.workflowNamespaces={argocd}' |
  grep -E '^NAME|^LAST|^STATUS|^REVISION|^TEST'

# Patch the argo-workflow-role to allow patching of the ApplicationSets
k0 -n argocd patch role argo-workflows-workflow --type json \
  -p '[
        {
          "op": "add",
          "path": "/rules/-",
          "value": {
            "apiGroups":["argoproj.io"],
            "resources":["applicationsets"],
            "verbs":["get","watch","patch"]
          }
        }
      ]'

echo
echo "ArgoWF WebUI: http://${IP[${MNGR}]}:2746"

#------------------------------------------------------------------------------
# [i] Bootstrap DAG
#------------------------------------------------------------------------------

blue "---[ Bootstrap DAG ]----------------------------------------------------"

# Install Argo WorkflowTemplates
helm template ./charts/wftemplates | k0 -n argocd apply -f -

# Create a secret with ArgoCD credentials
k0 create secret generic argocd-credentials \
 --from-literal=password="${ARGOCD_PASS}" \
 --from-literal=username='admin' \
 --from-literal=token='' \
 --dry-run=client -o yaml | k0 -n argocd apply -f -

# Create the bootstrap workflow
argo --context kube-00 submit -n argocd -w <(cat << EOF
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: bootstrap-
spec:
  entrypoint: stages
  serviceAccountName: argo-workflow
  templates:
  - name: stages
    dag:
      tasks:
      - name: prometheus
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=prometheus
      - name: vault
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=vault
      - name: cert-manager
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=cert-manager
      - name: populate-vault
        dependencies: [vault]
        templateRef:
          name: populate-vault
          template: populate-vault
        arguments:
          parameters:
          - name: vault-address
            value: http://${IP[${MNGR}]}:8200
          - name: vault-token
            value: root
      - name: istio-issuers
        dependencies: [populate-vault, cert-manager]
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=istio-issuers
      - name: istio-base
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=istio-base
      - name: istio-cni
        dependencies: [istio-base]
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=istio-cni
      - name: istio-pilot
        dependencies: [istio-base, istio-issuers]
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=istio-pilot
      - name: istio-igws
        dependencies: [istio-pilot]
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=istio-igws
      - name: istio-ewgw
        dependencies: [istio-pilot]
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=istio-ewgw
      - name: istio-tags
        dependencies: [istio-pilot]
        templateRef:
          name: argocd-sync-and-wait
          template: argocd-sync-and-wait
        arguments:
          parameters:
          - name: selector
            value: name=istio-tags
EOF
)

#------------------------------------------------------------------------------
# [i] Enable Istio endpoint discovery
#------------------------------------------------------------------------------

blue "---[ Istio remote secrets ]---------------------------------------------"

for STAMP in $(list stamps); do
  CLUS=(${STAMPS[${STAMP}]})
  istioctl create-remote-secret --context "${CLUS[0]}" --name="${CLUS[0]}" | \
  kubectl --context "${CLUS[1]}" apply -f -
  istioctl create-remote-secret --context "${CLUS[1]}" --name="${CLUS[1]}" | \
  kubectl --context "${CLUS[0]}" apply -f -
done

#------------------------------------------------------------------------------
# Deploy some workloads
#------------------------------------------------------------------------------

swarmctl --context 'pasta-*|pizza-*' i --istio-revision stable
swarmctl --context 'pasta-*|pizza-*' w 1:2 --istio-revision stable
