#!/usr/bin/env bash

##-----------------------------------------------------------------------------
## TODO Create a cli tool that will be installed via brew and will be used to
## create the VMs and install a controller. VMs will be created by multipass
## using remote custom images pre-created with packer.
##-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# [i] Initializations
#------------------------------------------------------------------------------

# Bash strict mode
set -euo pipefail

# Change to the execution directory
cd "$(dirname "$0")"/..

# shellcheck source=/dev/null
source lib/misc.sh

# Global variables
CLUS0="kube-00"
CLUS1="kube-01"
CLUS2="kube-02"

declare -A STAMP=(
  [name]="red-ballon"
  [clusters]="${CLUS1} ${CLUS2}"
)

#------------------------------------------------------------------------------
# [i] Pull-through image cache
#------------------------------------------------------------------------------

echo -e "\n---[ Pull-through registries ]-----------------------------------\n"

docker start registry-docker.io 2>/dev/null || docker run -d -p 5011:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://registry-1.docker.io \
  --restart always \
  --name registry-docker.io \
  registry:2

docker start registry-quay.io 2>/dev/null || docker run -d -p 5012:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://quay.io \
  --restart always \
  --name registry-quay.io \
  registry:2

docker start registry-ghcr.io 2>/dev/null || docker run -d -p 5013:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://ghcr.io \
  --restart always \
  --name registry-ghcr.io \
  registry:2

#------------------------------------------------------------------------------
# [i] Create clusters
#------------------------------------------------------------------------------

echo -e "\n---[ Multipass VMs ]---------------------------------------------\n"

{ multipass start ${CLUS0} 2>/dev/null || (sleep 00; launch_k8s ${CLUS0}) } &
{ multipass start ${CLUS1} 2>/dev/null || (sleep 05; launch_k8s ${CLUS1}) } &
{ multipass start ${CLUS2} 2>/dev/null || (sleep 10; launch_k8s ${CLUS2}) } &

wait

declare -A IP=(
  [${CLUS0}]="$(multipass info ${CLUS0} | grep IPv4 | awk '{print $2}')"
  [${CLUS1}]="$(multipass info ${CLUS1} | grep IPv4 | awk '{print $2}')"
  [${CLUS2}]="$(multipass info ${CLUS2} | grep IPv4 | awk '{print $2}')"
)

#------------------------------------------------------------------------------
# [i] Setup KUBECONFIG
#------------------------------------------------------------------------------

KUBECONFIG=~/.kube/config:tmp/${CLUS0}/config:tmp/${CLUS1}/config:tmp/${CLUS2}/config \
kubectl config view --flatten > ./tmp/config && cp ./tmp/config ~/.kube/config

#------------------------------------------------------------------------------
# [i] Setup the ArgoCD client and add clusters
#------------------------------------------------------------------------------

echo -e "\n---[ ArgoCD ]----------------------------------------------------\n"

ARGOCD_PASS=$(
  kubectl --context ${CLUS0} -n argocd \
  get secret argocd-initial-admin-secret \
  -o jsonpath='{.data.password}' | base64 -d
)

argocd context ${CLUS0} 2> /dev/null || {

  argocd login "${IP[${CLUS0}]}" \
    --insecure \
    --name ${CLUS0} \
    --username admin \
    --password "${ARGOCD_PASS}"

  argocd cluster add -y "${CLUS1}"
  argocd cluster add -y "${CLUS2}"
}

kubectl --context ${CLUS0} apply -f ./conf/argocd-cm.yaml

sleep 2; ALIST=$(argocd app list)

##-----------------------------------------------------------------------------
## TODO Deploy a controller to ${CLUS0} that will take care of everything below
## by reconciling a Stamp CRDs that will be created after deploying the
## controller.
##-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# [i] Setup CoreDNS server DNS entries for demo.lab
#------------------------------------------------------------------------------

echo -e "\n---[ CoreDNS ]---------------------------------------------------\n"

for CLUSTER in ${STAMP[clusters]}; do

kubectl --context "${CLUSTER}" -n kube-system create cm coredns-custom \
--dry-run=client -o yaml --from-literal=demo.server="demo.lab {
  hosts {
    ttl 60
    ${IP[${CLUS0}]} vault.demo.lab
    ${IP[${CLUSTER}]} httpbin.demo.lab
    fallthrough
  }
}" | kubectl --context "${CLUSTER}" -n kube-system apply -f -

done

#------------------------------------------------------------------------------
# [i] Deploy vault
#------------------------------------------------------------------------------

echo -e "\n---[ Deploy Vault ]----------------------------------------------\n"

kubectl --context ${CLUS0} apply -f ./conf/argocd-vault.yaml

[ "$(echo "${ALIST}" | grep vault | grep -c 'Synced  Healthy')" -eq 1 ] || {
  echo "argocd app sync vault"
  argocd app sync vault > /dev/null
  argocd app wait vault > /dev/null
}

#------------------------------------------------------------------------------
# [i] Populate vault
#------------------------------------------------------------------------------

echo -e "\n---[ Populate Vault ]--------------------------------------------\n"

export VAULT_ADDR="http://${IP[${CLUS0}]}:8200"
export VAULT_TOKEN=root

while ! vault status &>/dev/null; do sleep 1; done

# Root CA for the stamp
vault secrets list | grep -q "stamp/${STAMP[name]}" || {
  vault secrets enable --path "stamp/${STAMP[name]}" \
  -description "PKI for the ${STAMP[name]} stamp" pki
  vault secrets tune -max-lease-ttl=87600h "stamp/${STAMP[name]}"
  vault write -field=certificate "stamp/${STAMP[name]}/root/generate/internal" \
  common_name="${STAMP[name]}" ttl=87600h > /dev/null
  vault write "stamp/${STAMP[name]}/config/urls" \
     issuing_certificates="${VAULT_ADDR}/v1/stamp/${STAMP[name]}/ca" \
     crl_distribution_points="${VAULT_ADDR}/v1/stamp/${STAMP[name]}/crl"
}

# Create a policy for cert-manager to issue intermediate CAs
vault policy list | grep -q "${STAMP[name]}-cert-manager" || {
vault policy write "${STAMP[name]}-cert-manager" - << EOF
path "stamp/${STAMP[name]}/root/sign-intermediate" {
  capabilities = ["create", "read", "update"]
}
path "stamp/${STAMP[name]}/intermediate/set-signed" {
  capabilities = ["create", "update"]
}
path "stamp/${STAMP[name]}/roles/ica" {
  capabilities = ["read"]
}
EOF
}

# Create an AppRole for cert-manager to issue intermediate CAs
vault auth list | grep -q 'approle' || {
  vault auth enable approle
  vault write "auth/approle/role/${STAMP[name]}-cert-manager" \
    secret_id_ttl=0 \
    token_num_uses=0 \
    token_ttl=0 \
    token_max_ttl=0 \
    secret_id_num_uses=0 \
    token_policies="${STAMP[name]}-cert-manager"
}

#------------------------------------------------------------------------------
# [i] Deploy cert-manager
#------------------------------------------------------------------------------

echo -e "\n---[ cert-manager ]----------------------------------------------\n"

kubectl --context ${CLUS0} apply -f ./conf/argocd-cert-manager.yaml

[ "$(echo "${ALIST}" | grep cert-manager | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-cert-manager ${CLUS2}-cert-manager"
  argocd app sync "${CLUS1}-cert-manager" "${CLUS2}-cert-manager" > /dev/null
  argocd app wait "${CLUS1}-cert-manager" "${CLUS2}-cert-manager" > /dev/null
}

#------------------------------------------------------------------------------
# [i] Create Istio ICA certificates
#------------------------------------------------------------------------------

echo -e "\n---[ Istio ICA ]-------------------------------------------------\n"

ROLE_ID=$(
  vault read -format json \
  "auth/approle/role/${STAMP[name]}-cert-manager/role-id" | \
  jq -r '.data.role_id'
)

SECRET_ID_B64=$(
  vault write -format json \
  -f "auth/approle/role/${STAMP[name]}-cert-manager/secret-id" | \
  jq -r '.data.secret_id' | base64 -w0
)

for CLUSTER in ${STAMP[clusters]}; do

kubectl create namespace istio-system --dry-run=client \
-o yaml | kubectl --context "${CLUSTER}" apply -f -

kubectl --context "${CLUSTER}" apply -f - << EOF
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: vault-ica-approle
  namespace: istio-system
data:
  secretId: ${SECRET_ID_B64}
EOF

kubectl --context "${CLUSTER}" apply -f - << EOF
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: vault-ica
  namespace: istio-system
spec:
  vault:
    path: stamp/${STAMP[name]}/root/sign-intermediate
    server: http://vault.demo.lab:8200
    auth:
      appRole:
        path: approle
        roleId: ${ROLE_ID}
        secretRef:
          name: vault-ica-approle
          key: secretId
EOF

kubectl --context "${CLUSTER}" apply -f - << EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: istio-cluster-ica
  namespace: istio-system
spec:
  secretName: cacerts
  commonName: "${CLUSTER}"
  isCA: true
  duration: 43800h
  renewBefore: 8760h
  privateKey:
    rotationPolicy: Always
  issuerRef:
    name: vault-ica
    kind: Issuer
EOF

done

#------------------------------------------------------------------------------
# [i] cert-manager CA Issuer and test certificate
#------------------------------------------------------------------------------

echo -e "\n---[ cert-manager CA Issuer ]------------------------------------\n"

for CLUSTER in ${STAMP[clusters]}; do

kubectl --context "${CLUSTER}" apply -f - << EOF
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: ingressgateway
  namespace: istio-system
spec:
  ca:
    secretName: cacerts
EOF

kubectl --context "${CLUSTER}" apply -f - << EOF
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: ingressgateway
  namespace: istio-system
spec:
  secretName: istio-ingressgateway-certs
  commonName: "istio-${CLUSTER}-ingressgateway"
  duration: 43800h
  renewBefore: 8760h
  dnsNames:
  - "*.demo.lab"
  - "*.alt.lab"
  - "test.something.lab"
  privateKey:
    rotationPolicy: Always
  issuerRef:
    name: ingressgateway
    kind: Issuer
EOF

done

#------------------------------------------------------------------------------
# [i] Wait for all certificates to be issued
#------------------------------------------------------------------------------

echo -e "\n---[ Waiting for certs ]-----------------------------------------\n"

k --context "${CLUS1}" wait --for=condition=Ready certificate -A --all &
k --context "${CLUS2}" wait --for=condition=Ready certificate -A --all &

wait

#------------------------------------------------------------------------------
# [i] Deploy Istio
#------------------------------------------------------------------------------

echo -e "\n---[ Istio ]-----------------------------------------------------\n"

kubectl --context ${CLUS0} apply -f ./conf/argocd-istio.yaml

# Base
[ "$(echo "${ALIST}" | grep istio-base | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-base ${CLUS2}-istio-base"
  argocd app sync "${CLUS1}-istio-base" "${CLUS2}-istio-base" > /dev/null
  argocd app wait "${CLUS1}-istio-base" "${CLUS2}-istio-base" > /dev/null
}

# Cni
[ "$(echo "${ALIST}" | grep istio-cni | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-cni ${CLUS2}-istio-cni"
  argocd app sync "${CLUS1}-istio-cni" "${CLUS2}-istio-cni" > /dev/null
  argocd app wait "${CLUS1}-istio-cni" "${CLUS2}-istio-cni" > /dev/null
}

# Pilot
[ "$(echo "${ALIST}" | grep istio-pilot | grep -c 'Synced  Healthy')" -eq 2 ] || {
 echo "argocd app sync ${CLUS1}-istio-pilot ${CLUS2}-istio-pilot"
 argocd app sync "${CLUS1}-istio-pilot" "${CLUS2}-istio-pilot" > /dev/null
 argocd app wait "${CLUS1}-istio-pilot" "${CLUS2}-istio-pilot" > /dev/null
}

# IngressGateways
[ "$(echo "${ALIST}" | grep istio-igws | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-igws ${CLUS2}-istio-igws"
  argocd app sync "${CLUS1}-istio-igws" "${CLUS2}-istio-igws" > /dev/null
  argocd app wait "${CLUS1}-istio-igws" "${CLUS2}-istio-igws" > /dev/null
}

# East-West gateway
[ "$(echo "${ALIST}" | grep istio-ewgw | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-ewgw ${CLUS2}-istio-ewgw"
  argocd app sync "${CLUS1}-istio-ewgw" "${CLUS2}-istio-ewgw" > /dev/null
  argocd app wait "${CLUS1}-istio-ewgw" "${CLUS2}-istio-ewgw" > /dev/null
}

#------------------------------------------------------------------------------
# [i] Istio Gateway
#------------------------------------------------------------------------------

echo -e "\n---[ Catch-all Istio Gateway ]-----------------------------------\n"

for CLUSTER in ${STAMP[clusters]}; do

kubectl --context "${CLUSTER}" apply -f - << EOF
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: ingress-gateway
  namespace: istio-system
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 443
      name: https
      protocol: HTTPS
    hosts:
    - "*"
    tls:
      mode: SIMPLE
      credentialName: istio-ingressgateway-certs
EOF

done

#------------------------------------------------------------------------------
# [i] Enable Istio endpoint discovery
#------------------------------------------------------------------------------

echo -e "\n---[ Istio remote secrets ]--------------------------------------\n"

istioctl x create-remote-secret --context "${CLUS1}" --name="${CLUS1}" | \
kubectl --context "${CLUS2}" apply -f -
istioctl x create-remote-secret --context "${CLUS2}" --name="${CLUS2}" | \
kubectl --context "${CLUS1}" apply -f -

#------------------------------------------------------------------------------
# [i] Deploy the httpbin service
#------------------------------------------------------------------------------

echo -e "\n---[ httpbin ]---------------------------------------------------\n"

kubectl --context ${CLUS0} apply -f ./conf/argocd-httpbin.yaml

[ "$(echo "${ALIST}" | grep httpbin | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-httpbin ${CLUS2}-httpbin"
  argocd app sync "${CLUS1}-httpbin" "${CLUS2}-httpbin" > /dev/null
  argocd app wait "${CLUS1}-httpbin" "${CLUS2}-httpbin" > /dev/null
}

#------------------------------------------------------------------------------
# [?] Setup a non-k8s workload (optional)
#------------------------------------------------------------------------------

[ -z "${SKIP_VM}" ] && {

  echo -e "\n---[ VM setup ]--------------------------------------------------\n"

  # Launch the VM
  multipass start virt-01 2>/dev/null || launch_vms virt-01

  # Generate the VM files
  istioctl x workload entry configure \
    --context ${CLUS1} \
    -n httpbin \
    -r 1-17-1 \
    --name httpbin \
    --clusterID ${CLUS1} \
    --autoregister \
    -o ./tmp/virt-01/vm-files

  # Use the custom address defined in ISTIOD_CUSTOM_HOST
  grep -rl 'istiod-1-17-1.istio-system.svc' ./tmp | \
  xargs sed -i "s/istiod-1-17-1.istio-system.svc/istiod.${CLUS1}/g"

  # Download the istio-sidecar.deb
  [ -f ./tmp/virt-01/istio-sidecar.deb ] || {
    curl -sLo ./tmp/virt-01/istio-sidecar.deb \
    https://storage.googleapis.com/istio-release/releases/1.17.1/deb/istio-sidecar-"$(arch)".deb
  }

  # Setup the VM files
  cp ./conf/vm-setup ./tmp/virt-01
  multipass exec virt-01 -- sudo /mnt/host/vm-setup
}

#------------------------------------------------------------------------------
# Echo ArgoCD info
#------------------------------------------------------------------------------

echo -e "\n---[ Info ]------------------------------------------------------\n"

echo "ArgoCD WebUI: https://${IP[${CLUS0}]}"
echo "ArgoCD User: admin"
echo "ArgoCD Pass: ${ARGOCD_PASS}"
