#!/usr/bin/env bash

##-----------------------------------------------------------------------------
## TODO Create a cli tool that will be installed via brew and will be used to
## create the VMs and install a controller. VMs will be created by multipass
## using remote custom images pre-created with packer.
##-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# [i] Initializations
#------------------------------------------------------------------------------

# Bash strict mode
set -euo pipefail

# Change to the execution directory
cd "$(dirname "$0")"/..

# shellcheck source=/dev/null
source lib/common.sh
# shellcheck source=/dev/null
source lib/misc.sh

#------------------------------------------------------------------------------
# [i] Pull-through image cache
#------------------------------------------------------------------------------

echo -e "\n---[ Pull-through registries ]-----------------------------------\n"

docker start registry-docker.io 2>/dev/null || docker run -d -p 5011:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://registry-1.docker.io \
  --restart always \
  --name registry-docker.io \
  registry:2

docker start registry-quay.io 2>/dev/null || docker run -d -p 5012:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://quay.io \
  --restart always \
  --name registry-quay.io \
  registry:2

docker start registry-ghcr.io 2>/dev/null || docker run -d -p 5013:5000 \
  -e REGISTRY_PROXY_REMOTEURL=https://ghcr.io \
  --restart always \
  --name registry-ghcr.io \
  registry:2

#------------------------------------------------------------------------------
# [i] Create clusters
#------------------------------------------------------------------------------

echo -e "\n---[ Multipass VMs ]---------------------------------------------\n"

MPLIST=$(multipass list)

# Start the management cluster
echo "${MPLIST}" | grep "${CLUS0}" | grep -q Running ||
{ multipass start "${CLUS0}" 2>/dev/null || (launch_k8s "${CLUS0}") } &

# Start the stamp clusters
for STAMP in "${!STAMPS[@]}"; do for CLUSTER in ${STAMPS[${STAMP}]}; do
    echo "${MPLIST}" | grep "${CLUSTER}" | grep -q Running ||
    { sleep 5; { multipass start "${CLUSTER}" 2>/dev/null || (launch_k8s "${CLUSTER}") } & }
done done

wait

# Get the IPs
declare -A IP
IP[${CLUS0}]=$(multipass info "${CLUS0}" | grep IPv4 | awk '{print $2}')
for STAMP in "${!STAMPS[@]}"; do for CLUSTER in ${STAMPS[${STAMP}]}; do
    IP[${CLUSTER}]=$(multipass info "${CLUSTER}" | grep IPv4 | awk '{print $2}')
done done

# Echo all the IPs
for CLUSTER in "${!IP[@]}"; do echo "${CLUSTER} = ${IP[${CLUSTER}]}"; done

#------------------------------------------------------------------------------
# [i] Setup KUBECONFIG
#------------------------------------------------------------------------------

KUBECONFIG=~/.kube/config:tmp/${CLUS0}/config:tmp/${CLUS1}/config:tmp/${CLUS2}/config \
kubectl config view --flatten > ./tmp/config && cp ./tmp/config ~/.kube/config

#------------------------------------------------------------------------------
# [i] Setup the ArgoCD client and add the clusters
#------------------------------------------------------------------------------

echo -e "\n---[ ArgoCD ]----------------------------------------------------\n"

ARGOCD_PASS=$(
  kubectl --context "${CLUS0}" -n argocd \
  get secret argocd-initial-admin-secret \
  -o jsonpath='{.data.password}' | base64 -d
)

argocd context "${CLUS0}" 2> /dev/null || {

  # Login to ArgoCD
  argocd login "${IP[${CLUS0}]}" \
    --insecure \
    --name "${CLUS0}" \
    --username admin \
    --password "${ARGOCD_PASS}"

  # Add clusters with labels
  argocd cluster add -y "${CLUS1}" --label name="${CLUS1}" --label stamp="${STAMP[name]}"
  argocd cluster add -y "${CLUS2}" --label name="${CLUS2}" --label stamp="${STAMP[name]}"
}

# Add the ArgoCD configmap with custom settings
kubectl --context "${CLUS0}" apply -f ./conf/argocd-cm.yaml

sleep 2; ALIST=$(argocd app list)

##-----------------------------------------------------------------------------
## TODO Deploy a controller to ${CLUS0} that will take care of everything below
## by reconciling a Stamp CRDs that will be created after deploying the
## controller.
##-----------------------------------------------------------------------------

#------------------------------------------------------------------------------
# [i] Setup CoreDNS server DNS entries for demo.lab
#------------------------------------------------------------------------------

echo -e "\n---[ CoreDNS ]---------------------------------------------------\n"

for CLUSTER in ${STAMP[clusters]}; do

kubectl --context "${CLUSTER}" -n kube-system create cm coredns-custom \
--dry-run=client -o yaml --from-literal=demo.server="demo.lab {
  hosts {
    ttl 60
    ${IP[${CLUS0}]} vault.demo.lab
    ${IP[${CLUSTER}]} httpbin.demo.lab
    fallthrough
  }
}" | kubectl --context "${CLUSTER}" -n kube-system apply -f -

done

#------------------------------------------------------------------------------
# [i] Deploy vault
#------------------------------------------------------------------------------

echo -e "\n---[ Deploy Vault ]----------------------------------------------\n"

kubectl --context "${CLUS0}" apply -Rf ./conf/argocd/vault

[ "$(echo "${ALIST}" | grep vault | grep -c 'Synced  Healthy')" -eq 1 ] || {
  echo "argocd app sync vault"
  argocd app sync vault > /dev/null
  argocd app wait vault > /dev/null
}

#------------------------------------------------------------------------------
# [i] Populate vault
#------------------------------------------------------------------------------

echo -e "\n---[ Populate Vault ]--------------------------------------------\n"

export VAULT_ADDR="http://${IP[${CLUS0}]}:8200"
export VAULT_TOKEN=root

while ! vault status &>/dev/null; do sleep 1; done

# Root CA for the stamp
vault secrets list | grep -q "stamp/${STAMP[name]}" || {
  vault secrets enable --path "stamp/${STAMP[name]}" \
  -description "PKI for the ${STAMP[name]} stamp" pki
  vault secrets tune -max-lease-ttl=87600h "stamp/${STAMP[name]}"
  vault write -field=certificate "stamp/${STAMP[name]}/root/generate/internal" \
  common_name="${STAMP[name]}" ttl=87600h > /dev/null
  vault write "stamp/${STAMP[name]}/config/urls" \
     issuing_certificates="${VAULT_ADDR}/v1/stamp/${STAMP[name]}/ca" \
     crl_distribution_points="${VAULT_ADDR}/v1/stamp/${STAMP[name]}/crl"
}

# Create a policy for cert-manager to issue intermediate CAs
vault policy list | grep -q "${STAMP[name]}-cert-manager" || {
vault policy write "${STAMP[name]}-cert-manager" - << EOF
path "stamp/${STAMP[name]}/root/sign-intermediate" {
  capabilities = ["create", "read", "update"]
}
path "stamp/${STAMP[name]}/intermediate/set-signed" {
  capabilities = ["create", "update"]
}
path "stamp/${STAMP[name]}/roles/ica" {
  capabilities = ["read"]
}
EOF
}

# Create an AppRole for cert-manager to issue intermediate CAs
vault auth list | grep -q 'approle' || {
  vault auth enable approle
  vault write "auth/approle/role/${STAMP[name]}-cert-manager" \
    secret_id_ttl=0 \
    token_num_uses=0 \
    token_ttl=0 \
    token_max_ttl=0 \
    secret_id_num_uses=0 \
    token_policies="${STAMP[name]}-cert-manager"
}

#------------------------------------------------------------------------------
# [n] Get the RoleID and SecretID for cert-manager
#------------------------------------------------------------------------------

ROLE_ID=$(
  vault read -format json \
  "auth/approle/role/${STAMP[name]}-cert-manager/role-id" | \
  jq -r '.data.role_id'
)

SECRET_ID_B64=$(
  vault write -format json \
  -f "auth/approle/role/${STAMP[name]}-cert-manager/secret-id" | \
  jq -r '.data.secret_id' | base64 -w0
)

#------------------------------------------------------------------------------
# [i] Deploy cert-manager
#------------------------------------------------------------------------------

echo -e "\n---[ cert-manager ]----------------------------------------------\n"

kubectl --context "${CLUS0}" apply -Rf ./conf/argocd/cert-manager

[ "$(echo "${ALIST}" | grep cert-manager | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-cert-manager ${CLUS2}-cert-manager"
  argocd app sync "${CLUS1}-cert-manager" "${CLUS2}-cert-manager" > /dev/null
  argocd app wait "${CLUS1}-cert-manager" "${CLUS2}-cert-manager" > /dev/null
}

#------------------------------------------------------------------------------
# [i] Deploy the Istio issuers chart
#------------------------------------------------------------------------------

echo -e "\n---[ Istio issuers ]---------------------------------------------\n"

helm template ./charts/istio-issuers \
--set roleID="${ROLE_ID}" \
--set secretID="${SECRET_ID_B64}" |
kubectl --context "${CLUS0}" apply -f -

[ "$(echo "${ALIST}" | grep issuers | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-issuers ${CLUS2}-istio-issuers"
  argocd app sync "${CLUS1}-istio-issuers" "${CLUS2}-istio-issuers" > /dev/null
  argocd app wait "${CLUS1}-istio-issuers" "${CLUS2}-istio-issuers" > /dev/null
}

#------------------------------------------------------------------------------
# [i] Deploy Istio
#------------------------------------------------------------------------------

echo -e "\n---[ Istio ]-----------------------------------------------------\n"

kubectl --context "${CLUS0}" apply -Rf ./conf/argocd/istio

# Base
[ "$(echo "${ALIST}" | grep istio-base | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-base ${CLUS2}-istio-base"
  argocd app sync "${CLUS1}-istio-base" "${CLUS2}-istio-base" > /dev/null
  argocd app wait "${CLUS1}-istio-base" "${CLUS2}-istio-base" > /dev/null
}

# Cni
[ "$(echo "${ALIST}" | grep istio-cni | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-cni ${CLUS2}-istio-cni"
  argocd app sync "${CLUS1}-istio-cni" "${CLUS2}-istio-cni" > /dev/null
  argocd app wait "${CLUS1}-istio-cni" "${CLUS2}-istio-cni" > /dev/null
}

# Pilot
[ "$(echo "${ALIST}" | grep istio-pilot | grep -c 'Synced  Healthy')" -eq 2 ] || {
 echo "argocd app sync ${CLUS1}-istio-pilot ${CLUS2}-istio-pilot"
 argocd app sync "${CLUS1}-istio-pilot" "${CLUS2}-istio-pilot" > /dev/null
 argocd app wait "${CLUS1}-istio-pilot" "${CLUS2}-istio-pilot" > /dev/null
}

# IngressGateways
[ "$(echo "${ALIST}" | grep istio-igws | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-igws ${CLUS2}-istio-igws"
  argocd app sync "${CLUS1}-istio-igws" "${CLUS2}-istio-igws" > /dev/null
  argocd app wait "${CLUS1}-istio-igws" "${CLUS2}-istio-igws" > /dev/null
}

# East-West gateway
[ "$(echo "${ALIST}" | grep istio-ewgw | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-istio-ewgw ${CLUS2}-istio-ewgw"
  argocd app sync "${CLUS1}-istio-ewgw" "${CLUS2}-istio-ewgw" > /dev/null
  argocd app wait "${CLUS1}-istio-ewgw" "${CLUS2}-istio-ewgw" > /dev/null
}

#------------------------------------------------------------------------------
# [i] Enable Istio endpoint discovery
#------------------------------------------------------------------------------

echo -e "\n---[ Istio remote secrets ]--------------------------------------\n"

istioctl x create-remote-secret --context "${CLUS1}" --name="${CLUS1}" | \
kubectl --context "${CLUS2}" apply -f -
istioctl x create-remote-secret --context "${CLUS2}" --name="${CLUS2}" | \
kubectl --context "${CLUS1}" apply -f -

#------------------------------------------------------------------------------
# [i] Deploy the httpbin service
#------------------------------------------------------------------------------

echo -e "\n---[ httpbin ]---------------------------------------------------\n"

kubectl --context "${CLUS0}" apply -Rf ./conf/argocd/httpbin

[ "$(echo "${ALIST}" | grep httpbin | grep -c 'Synced  Healthy')" -eq 2 ] || {
  echo "argocd app sync ${CLUS1}-httpbin ${CLUS2}-httpbin"
  argocd app sync "${CLUS1}-httpbin" "${CLUS2}-httpbin" > /dev/null
  argocd app wait "${CLUS1}-httpbin" "${CLUS2}-httpbin" > /dev/null
}

#------------------------------------------------------------------------------
# [?] Setup a non-k8s workload (optional)
#------------------------------------------------------------------------------

[ -z "${SKIP_VM}" ] && {

  echo -e "\n---[ VM setup ]--------------------------------------------------\n"

  # Launch the VM
  multipass start virt-01 2>/dev/null || launch_vms virt-01

  # Generate the VM files
  istioctl x workload entry configure \
    --context "${CLUS1}" \
    -n httpbin \
    -r 1-17-1 \
    --name httpbin \
    --clusterID "${CLUS1}" \
    --autoregister \
    -o ./tmp/virt-01/vm-files

  # Use the custom address defined in ISTIOD_CUSTOM_HOST
  grep -rl 'istiod-1-17-1.istio-system.svc' ./tmp | \
  xargs sed -i "s/istiod-1-17-1.istio-system.svc/istiod.${CLUS1}/g"

  # Download the istio-sidecar.deb
  [ -f ./tmp/virt-01/istio-sidecar.deb ] || {
    curl -sLo ./tmp/virt-01/istio-sidecar.deb \
    https://storage.googleapis.com/istio-release/releases/1.17.1/deb/istio-sidecar-"$(arch)".deb
  }

  # Setup the VM files
  cp ./conf/vm-setup ./tmp/virt-01
  multipass exec virt-01 -- sudo /mnt/host/vm-setup
}

#------------------------------------------------------------------------------
# Echo ArgoCD info
#------------------------------------------------------------------------------

echo -e "\n---[ Info ]------------------------------------------------------\n"

echo "ArgoCD WebUI: https://${IP[${CLUS0}]}"
echo "ArgoCD User: admin"
echo "ArgoCD Pass: ${ARGOCD_PASS}"
