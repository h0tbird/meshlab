<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The MeshLab Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The MeshLab Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the MeshLab repository! In this lab, you will find a setup to validate Istio configurations in a cell-based architecture. Each cell is an architecture block representing a unit of isolation and scalability. The lab defines two cells, named <code>pasta</code> and <code>pizza</code>, each composed of two clusters. Each cluster is configured with a multi-primary Istio control-plane for high availability and resilience.</p>
<p>Although the cells share the same root CA for their cryptographic material, each one uses a different SPIFFE trustDomain and each cluster within a cell has its own intermediate CA. Locality failover is possible within the clusters of a cell, and all mTLS cross-cluster traffic flows through east-west Istio gateways because pod networks have non-routable CIDRs.</p>
<p>The purpose of this lab is to test and validate different Istio configurations in a realistic environment.</p>
<p>Helm is used to deploy:</p>
<ul>
<li><a href="https://artifacthub.io/packages/helm/argo-cd-oci/argo-cd">ArgoCD</a></li>
<li><a href="https://artifacthub.io/packages/helm/argo/argo-workflows">Argo Workflows</a></li>
</ul>
<p>Argo Workflows and ArgoCD are used to deploy:</p>
<ul>
<li><a href="https://artifacthub.io/packages/helm/hashicorp/vault">Vault</a></li>
<li><a href="https://artifacthub.io/packages/helm/cert-manager/cert-manager">cert-manager</a></li>
<li><a href="https://artifacthub.io/packages/helm/prometheus-community/prometheus">Prometheus</a></li>
<li><a href="https://artifacthub.io/packages/helm/grafana/grafana">Grafana</a></li>
<li><a href="https://artifacthub.io/packages/helm/opentelemetry-helm/opentelemetry-collector">OTEL Collector</a></li>
<li><a href="https://artifacthub.io/packages/helm/istio-official/base">Istio</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>To quickly get started with the MeshLab repository, follow these simple steps:</p>
<pre><code class="language-bash">./bin/meshlab-multipass create
./bin/meshlab-multipass suspend
./bin/meshlab-multipass delete
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="components"><a class="header" href="#components">Components</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pull-through-registries"><a class="header" href="#pull-through-registries">Pull-through registries</a></h1>
<p>A pull-through registry is a proxy that sits between your local Docker
installation and a remote Docker registry. It caches the images you pull from
the remote registry, and if another user on the same network tries to pull the
same image, the pull-through registry will serve it to them directly, rather
than pulling it again from the remote registry. The Container Runtime Interface
(CRI) in this lab is set up to use local pull-through registries for the
remote registries <code>docker.io</code>, <code>quay.io</code> and <code>ghcr.io</code> on each cluster.</p>
<p>List all images in a registry:</p>
<pre><code class="language-console">curl -s 127.0.0.1:5011/v2/_catalog | jq # docker.io
curl -s 127.0.0.1:5012/v2/_catalog | jq # quay.io
curl -s 127.0.0.1:5013/v2/_catalog | jq # ghcr.io
</code></pre>
<p>List tags for a given image:</p>
<pre><code class="language-console">curl -s 127.0.0.1:5012/v2/argoproj/argocd/tags/list | jq
</code></pre>
<p>Get the manifest for a given image and tag:</p>
<pre><code class="language-console">curl -s http://127.0.0.1:5012/v2/argoproj/argocd/manifests/v2.4.7 | jq
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multipass"><a class="header" href="#multipass">Multipass</a></h1>
<p><a href="https://multipass.run/">Multipass</a> from Canonical is a tool for launching, managing, and orchestrating Linux virtual machines on local computers, simplifying the process for development, testing, and other purposes. It provides a user-friendly command-line interface and integrates with other tools for automation and customization.</p>
<p>Stop/start multipassd:</p>
<pre><code class="language-console">sudo launchctl unload /Library/LaunchDaemons/com.canonical.multipassd.plist
sudo launchctl load -w /Library/LaunchDaemons/com.canonical.multipassd.plist
</code></pre>
<p>Restart multipassd:</p>
<pre><code class="language-console">sudo launchctl kickstart -k system/com.canonical.multipassd
</code></pre>
<p>Directories of interest:</p>
<pre><code class="language-console">sudo tree /var/root/Library/Caches/multipassd
sudo tree /var/root/Library/Application\ Support/multipassd
sudo tree /Library/Application\ Support/com.canonical.multipass
</code></pre>
<p>List all available instances:</p>
<pre><code class="language-console">multipass list
</code></pre>
<p>Display information about all instances:</p>
<pre><code class="language-console">multipass info
</code></pre>
<p>Open a shell on a running instance:</p>
<pre><code>multipass shell pasta-1
</code></pre>
<p>Tail the logs:</p>
<pre><code class="language-console">sudo tail -f /Library/Logs/Multipass/multipassd.log
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hypervisorframework"><a class="header" href="#hypervisorframework">Hypervisor.framework</a></h1>
<p>The drivers utilized on MacOS, specifically <a href="https://github.com/moby/hyperkit">HyperKit</a> and <a href="https://www.qemu.org">QEMU</a>, rely on MacOS' <a href="https://developer.apple.com/documentation/hypervisor">Hypervisor.framework</a> to manage the networking stack for the instances. When an instance is created, the <code>Hypervisor.framework</code> on the host employs MacOS' <em>'Internet Sharing'</em> mechanism to establish a virtual switch. Each instance is then connected to this switch with a subnet address from:</p>
<pre><code class="language-console">$ sudo cat /Library/preferences/SystemConfiguration/com.apple.vmnet.plist | grep -A1 Shared_Net_Address
Password:
	&lt;key&gt;Shared_Net_Address&lt;/key&gt;
	&lt;string&gt;192.168.65.1&lt;/string&gt;
</code></pre>
<p>Furthermore, the host provides DHCP and DNS resolution services on this switch through the IP address 192.168.65.1, facilitated by the <code>bootpd</code> and <code>mDNSResponder</code> services running on the host machine. It is worth noting that attempting to manually edit the configuration file <code>/etc/bootpd.plist</code> is futile, as MacOS will regenerate it according to its own preferences.</p>
<p>Is the <code>bootpd</code> DHCP server alive?</p>
<pre><code class="language-console">sudo lsof -iUDP:67 -n -P
</code></pre>
<p>Start it:</p>
<pre><code class="language-console">sudo launchctl load -w /System/Library/LaunchDaemons/bootps.plist
</code></pre>
<p>Flush all DHCP leases:</p>
<pre><code class="language-console">sudo launchctl stop com.apple.bootpd
sudo rm -f /var/db/dhcpd_leases
sudo launchctl start com.apple.bootpd
</code></pre>
<p>It appears that at a certain juncture, <code>docker</code> and <code>multipass</code> ceased to share the same network bridge. Whichever starts first will occupy <code>bridge100</code> with the IP address <code>192.168.64.1</code>, while the subsequent one will take <code>bridge101</code> with the IP address <code>192.168.65.1</code>. Upon repeatedly stopping and starting these services, you will notice a sequential increment in the third octet of the <code>Shared_Net_Address</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cloud-init"><a class="header" href="#cloud-init">Cloud-init</a></h1>
<p><a href="https://cloudinit.readthedocs.io/en/latest">cloud-init</a> is a tool used to configure virtual machine instances in the cloud during their first boot. It simplifies the provisioning process, enabling quick setup of new environments with desired configurations. The following commands provide examples for monitoring and inspecting the cloud-init process on various nodes in the system, including logs and scripts run during the instance's first boot.</p>
<p>Tail the <code>cloud-init</code> logs:</p>
<pre><code class="language-console">multipass exec kube-00 -- tail -f /var/log/cloud-init-output.log
multipass exec pasta-1 -- tail -f /var/log/cloud-init-output.log
multipass exec pasta-2 -- tail -f /var/log/cloud-init-output.log
</code></pre>
<p>Inspect the rendered <code>runcmd</code>:</p>
<pre><code class="language-console">multipass exec kube-00 -- sudo cat /var/lib/cloud/instance/scripts/runcmd
multipass exec pasta-1 -- sudo cat /var/lib/cloud/instance/scripts/runcmd
multipass exec pasta-2 -- sudo cat /var/lib/cloud/instance/scripts/runcmd
multipass exec virt-01 -- sudo cat /var/lib/cloud/instance/scripts/runcmd
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="k3s"><a class="header" href="#k3s">k3s</a></h1>
<p><a href="https://k3s.io">k3s</a> is a lightweight version of Kubernetes designed for resource-constrained environments like IoT devices and edge computing. It requires fewer resources and has additional features such as simplified installation and compatibility with ARM architectures.</p>
<p>Run config check:</p>
<pre><code class="language-console">multipass exec pasta-1 -- bash -c "sudo k3s check-config"
multipass exec pasta-2 -- bash -c "sudo k3s check-config"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cilium"><a class="header" href="#cilium">Cilium</a></h1>
<p><a href="https://cilium.io/">Cilium</a> is an open source, cloud native solution for providing, securing, and observing network connectivity between workloads, fueled by the revolutionary Kernel technology eBPF.</p>
<p>Display status:</p>
<pre><code class="language-console">cilium --context pasta-1 status
</code></pre>
<p>Show status of ClusterMesh:</p>
<pre><code>cilium --context pasta-1 clustermesh status
</code></pre>
<p>Display status of daemon:</p>
<pre><code class="language-console">k --context pasta-1 -n kube-system exec ds/cilium -c cilium-agent -- cilium-dbg status
</code></pre>
<p>Display full details:</p>
<pre><code class="language-console">k --context pasta-1 -n kube-system exec ds/cilium -c cilium-agent -- cilium-dbg status --verbose
</code></pre>
<p>List services:</p>
<pre><code class="language-console">k --context pasta-1 -n kube-system exec ds/cilium -c cilium-agent -- cilium-dbg service list
</code></pre>
<p>Troubleshoot connectivity towards remote clusters:</p>
<pre><code class="language-console">k --context pasta-1 -n kube-system exec ds/cilium -c cilium-agent -- cilium-dbg troubleshoot clustermesh
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="argocd"><a class="header" href="#argocd">ArgoCD</a></h1>
<p><a href="https://argo-cd.readthedocs.io/en/stable/">ArgoCD</a> is a GitOps platform for Kubernetes applications that enables continuous delivery with declarative management and automation of deployments from Git repositories to multiple clusters. With its user-friendly interface, robust features, and deep Kubernetes integration, ArgoCD is a popular choice for automating application delivery.</p>
<p>List all the applications:</p>
<pre><code class="language-console">argocd app list
</code></pre>
<p>Manually sync applications:</p>
<pre><code class="language-console">argocd app sync -l name=istio-issuers --async
argocd app sync -l name=istio-base --async
argocd app sync -l name=istio-cni --async
argocd app sync -l name=istio-istiod --async
argocd app sync -l name=istio-nsgw --async
argocd app sync -l name=istio-ewgw --async
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coredns"><a class="header" href="#coredns">CoreDNS</a></h1>
<p><a href="https://coredns.io">CoreDNS</a> is a flexible, extensible DNS server that can be easily configured to provide custom DNS resolutions in Kubernetes clusters. It allows for dynamic updates, service discovery, and integration with external data sources, making it a popular choice for service discovery and network management in cloud-native environments.</p>
<p>Create DNS records for <code>mesh.lab</code>:</p>
<pre><code class="language-console">k --context pasta-1 -n kube-system create configmap coredns-custom --from-literal=demo.server='mesh.lab {
  hosts {
    ttl 60
    192.168.65.3 worker.service-1.mesh.lab
    192.168.65.3 worker.service-2.mesh.lab
    fallthrough
  }
}'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vault"><a class="header" href="#vault">Vault</a></h1>
<p>Blah, blah, blah...</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cert-manager"><a class="header" href="#cert-manager">cert-manager</a></h1>
<p>Cert-manager is an open-source software that helps automate the management and
issuance of TLS/SSL certificates in Kubernetes clusters. It integrates with
various certificate authorities (CAs) and can automatically renew certificates
before they expire, ensuring secure communication between services running in
the cluster.</p>
<p>Print the cert-manager CLI version and the deployed cert-manager version:</p>
<pre><code>cmctl --context pasta-1 version
</code></pre>
<p>This check attempts to perform a dry-run create of a cert-manager v1alpha2
<code>Certificate</code> resource in order to verify that CRDs are installed and all the
required webhooks are reachable by the K8S API server. We use v1alpha2 API to
ensure that the API server has also connected to the cert-manager conversion
webhook:</p>
<pre><code class="language-console">cmctl check api --context pasta-1
</code></pre>
<p>Get details about the current status of a cert-manager Certificate resource,
including information on related resources like <code>CertificateRequest</code> or <code>Order</code>:</p>
<pre><code class="language-console">cmctl --context pasta-1 --namespace istio-system status certificate istio-cluster-ica
</code></pre>
<p>Mark cert-manager <code>Certificate</code> resources for manual renewal:</p>
<pre><code class="language-console">cmctl renew --context pasta-1 --namespace istio-system istio-cluster-ica
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="istio"><a class="header" href="#istio">Istio</a></h1>
<p>Istio is an open-source service mesh platform that provides traffic management,
policy enforcement, and telemetry collection for microservices applications. It
helps in improving the reliability, security, and observability of
service-to-service communication in a cloud-native environment. By integrating
with popular platforms such as Kubernetes, Istio makes it easier to manage the
complexities of microservices architecture.</p>
<p>Lists the remote clusters each <code>istiod</code> instance is connected to:</p>
<pre><code class="language-console">istioctl --context pasta-1 remote-clusters
</code></pre>
<p>Access the <code>istiod</code> WebUI:</p>
<pre><code class="language-console">istioctl --context pasta-1 dashboard controlz deployment/istiod-1-22-2.istio-system
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="klipper-lb"><a class="header" href="#klipper-lb">klipper-lb</a></h1>
<p><code>klipper-lb</code> uses a host port for each <code>Service</code> of type <code>LoadBalancer</code> and
sets up iptables to forward the request to the cluster IP. The regular k8s
scheduler will find a free host port. If there are no free host ports, the
<code>Service</code> will stay in pending. There is one <code>DaemonSet</code> per <code>Service</code> of type
<code>LoadBalancer</code> and each <code>Pod</code> has one container per exposed <code>Service</code> port.</p>
<p>List the containers fronting the exposed <code>argocd-server</code> ports:</p>
<pre><code class="language-console">k --context kube-00 -n kube-system get ds -l svccontroller.k3s.cattle.io/svcname=argocd-server -o yaml | yq '.items[].spec.template.spec.containers[].name'
</code></pre>
<p>List the containers fronting the exposed <code>istio-eastwestgateway</code> ports:</p>
<pre><code class="language-console">k --context pasta-1 -n kube-system get ds -l svccontroller.k3s.cattle.io/svcname=istio-eastwestgateway -o yaml | yq '.items[].spec.template.spec.containers[].name'
</code></pre>
<p>List the containers fronting the exposed <code>istio-ingressgateway</code> ports:</p>
<pre><code class="language-console">k --context pasta-1 -n kube-system get ds -l svccontroller.k3s.cattle.io/svcname=istio-ingressgateway -o yaml | yq '.items[].spec.template.spec.containers[].name'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="envoy"><a class="header" href="#envoy">Envoy</a></h1>
<p>Envoy is an open-source proxy server designed for modern microservices
architectures, providing features such as load balancing, traffic management,
and service discovery. It runs standalone or integrated with a service mesh,
making it a powerful tool for microservices communication.</p>
<p>Inspect the <code>config_dump</code> of a VM:</p>
<pre><code class="language-console">multipass exec virt-01 -- curl -s localhost:15000/config_dump | istioctl pc listeners --file -
multipass exec virt-01 -- curl -s localhost:15000/config_dump | istioctl pc routes --file -
multipass exec virt-01 -- curl -s localhost:15000/config_dump | istioctl pc clusters --file -
multipass exec virt-01 -- curl -s localhost:15000/config_dump | istioctl pc secret --file -
</code></pre>
<p>Set debug log level on a given proxy:</p>
<pre><code class="language-console">istioctl pc log sleep-xxx.httpbin --level debug
k --context pasta-1 -n httpbin logs -f sleep-xxx -c istio-proxy
</code></pre>
<p>Access the WebUI of a given envoy proxy:</p>
<pre><code class="language-console">istioctl dashboard envoy sleep-xxx.httpbin
</code></pre>
<p>Dump the envoy config of an eastweast gateway:</p>
<pre><code class="language-console">k --context pasta-1 -n istio-system exec -it deployment/istio-eastwestgateway -- curl -s localhost:15000/config_dump
</code></pre>
<p>Dump the <code>common_tls_context</code> for a given envoy cluster:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin exec -i sleep-xxx -- \
curl -s localhost:15000/config_dump | jq '
  .configs[] |
  select(."@type"=="type.googleapis.com/envoy.admin.v3.ClustersConfigDump") |
  .dynamic_active_clusters[] |
  select(.cluster.name=="outbound|80||httpbin.httpbin.svc.cluster.local") |
  .cluster.transport_socket_matches[] |
  select(.name=="tlsMode-istio") |
  .transport_socket.typed_config.common_tls_context
'
</code></pre>
<p>List <code>LISTEN</code> ports:</p>
<pre><code class="language-console">k --context pasta-1 -n istio-system exec istio-eastwestgateway-xxx -- netstat -tuanp | grep LISTEN | sort -u
</code></pre>
<p>Check the status-port:</p>
<pre><code class="language-console">curl -o /dev/null -Isw "%{http_code}" http://10.0.16.124:31123/healthz/ready
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>Send requests to <code>service-1</code> from an unauthenticated out-of-cluster workstation via the north-south Istio ingress gateway:</p>
<pre><code class="language-console">IP=$(multipass list | awk '/pasta-1/ {print $3}')
curl -sk --resolve service-1.mesh.lab:443:${IP} https://service-1.mesh.lab/data | jq -r '.podName'
</code></pre>
<p>Same as above but with certificate validation:</p>
<pre><code class="language-console">IP=$(multipass list | awk '/pasta-1/ {print $3}')
k --context pasta-1 -n istio-system get secret cacerts -o json | jq -r '.data."ca.crt"' | base64 -d &gt; /tmp/ca.crt
curl -s --cacert /tmp/ca.crt --resolve service-1.mesh.lab:443:${IP} https://service-1.mesh.lab/data | jq -r '.podName'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="locality-load-balancing"><a class="header" href="#locality-load-balancing">Locality load balancing</a></h1>
<p>Istio's Locality Load Balancing (LLB) is a feature that helps distribute
traffic across different geographic locations in a way that minimizes latency
and maximizes availability. It routes traffic to the closest available instance
of the service, reducing network hops and improving performance, while also
providing fault tolerance and resilience. LLB is important for managing
microservices architectures.</p>
<p>From the perspective of <code>istio-nsgw</code>: get the endpoints, priority, and weight of <code>service-1</code>:</p>
<pre><code class="language-console"># Get a running pod name
POD=$(k --context pasta-1 -n istio-system get po -l istio=nsgw --no-headers | awk 'NR==1{print $1}')

# Add an ephemeral container to the running pod
k --context pasta-1 -n istio-system debug -it \
--attach=false --image=istio/base --target=istio-proxy --container=debugger \
${POD} -- bash

# Watch for the endpoints
watch "istioctl --context pasta-1 -n istio-system pc endpoint deploy/istio-nsgw | grep -E '^END|service-1'; echo; k --context pasta-1 -n istio-system exec -it ${POD} -c debugger -- curl -X POST localhost:15000/clusters | grep '^outbound.*service-1' | grep -E 'zone|region|::priority|::weight' | sort | sed -e '/:zone:/s/$/\n/'"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tls"><a class="header" href="#tls">TLS</a></h1>
<p>TLS 1.3 is the latest version of the TLS protocol. TLS, which is used by HTTPS
and other network protocols for encryption, is the modern version of SSL. TLS
1.3 dropped support for older, less secure cryptographic features, and it
speeds up TLS handshakes, among other improvements.</p>
<p>Setup a place to dump the crypto material:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin patch deployment sleep --type merge -p '
spec:
  template:
    metadata:
      annotations:
        sidecar.istio.io/userVolume: "[{\"name\":\"sniff\", \"emptyDir\":{\"medium\":\"Memory\"}}]"
        sidecar.istio.io/userVolumeMount: "[{\"name\":\"sniff\", \"mountPath\":\"/sniff\"}]"
        proxy.istio.io/config: |
          proxyMetadata:
            OUTPUT_CERTS: /sniff
'
</code></pre>
<p>Write the required per-session TLS secrets to a file (<a href="https://github.com/istio/istio/blob/5f90e4b9ae19800f4c539628ae038ec118835610/pilot/pkg/networking/core/v1alpha3/envoyfilter/cluster_patch_test.go#L241-L262">source</a>):</p>
<pre><code class="language-console">k --context pasta-1 apply -f - &lt;&lt; EOF
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: httpbin
  namespace: httpbin
spec:
  workloadSelector:
    labels:
      app: sleep
  configPatches:
  - applyTo: CLUSTER
    match:
      context: SIDECAR_OUTBOUND
      cluster:
        service: "httpbin.httpbin.svc.cluster.local"
        portNumber: 80
    patch:
      operation: MERGE
      value:
        transport_socket:
          name: "envoy.transport_sockets.tls"
          typed_config:
            "@type": "type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext"
            common_tls_context:
              key_log:
                path: /sniff/keylog
EOF
</code></pre>
<p>Restart envoy to kill all TCP connections and force new TLS handshakes:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin exec -it deployment/sleep -c istio-proxy -- curl -X POST localhost:15000/quitquitquit
</code></pre>
<p>Optionally, use this command to list all available endpoints:</p>
<pre><code class="language-console">istioctl --context pasta-1 pc endpoint deploy/httpbin.httpbin | egrep '^END|httpbin'
</code></pre>
<p>Start <code>tcpdump</code>:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin exec -it deployment/sleep -c istio-proxy -- sudo tcpdump -s0 -w /sniff/dump.pcap
</code></pre>
<p>Send a few requests to the endpoints listed above:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin exec -i deployment/sleep -- curl -s httpbin/hostname | jq -r 'hostname'
</code></pre>
<p>Stop <code>tcpdump</code> and download everything:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin cp -c istio-proxy sleep-xxx:sniff ~/sniff
</code></pre>
<p>Open it with Wireshark:</p>
<pre><code class="language-console">open ~/sniff/dump.pcap
</code></pre>
<p>Filter by <code>tls.handshake.type == 1</code> and follow the TLS stream of a <code>Client Hello</code> packet.
Right click a <code>TLSv1.3</code> packet then <code>Protocol Preferences</code> --&gt; <code>Transport Layer Security</code> --&gt; <code>(Pre)-Master-Secret log filename</code> and provide the path to the <code>keylog</code> file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="certificates"><a class="header" href="#certificates">Certificates</a></h1>
<p>Find below a collection of commands to troubleshoot certificate issues.</p>
<p>Connect to the externally exposed <code>istiod</code> service and inspect the certificate bundle it presents:</p>
<pre><code class="language-console">step certificate inspect --bundle --servername istiod-1-19-6.istio-system.svc https://192.168.65.3:15012 --roots /path/to/root-ca.pem
step certificate inspect --bundle --servername istiod-1-19-6.istio-system.svc https://192.168.65.3:15012 --insecure
</code></pre>
<p>Inspect the certificate chain provided by a given workload:</p>
<pre><code class="language-console">istioctl --context pasta-1 pc secret httpbin-xxxxxxxxxx-yyyyy.httpbin -o json | jq -r '.dynamicActiveSecrets[] | select(.name=="default") | .secret.tlsCertificate.certificateChain.inlineBytes' | base64 -d | step certificate inspect --bundle
</code></pre>
<p>Inspect the certificate root CA present in a given workload:</p>
<pre><code class="language-console">istioctl --context pasta-1 pc secret sleep-xxxxxxxxxx-yyyyy.httpbin -o json | jq -r '.dynamicActiveSecrets[] | select(.name=="ROOTCA") | .secret.validationContext.trustedCa.inlineBytes' | base64 -d | step certificate inspect --bundle
</code></pre>
<p>Similar as above but this time as a client:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin exec -it deployment/sleep -c istio-proxy -- openssl s_client -showcerts httpbin:80
</code></pre>
<p>Get details about the status of a cert-manager managed certificate:</p>
<pre><code class="language-console">cmctl --context pasta-1 --namespace applab-blau status certificate blau
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development"><a class="header" href="#development">Development</a></h1>
<p>Provision only one VM:</p>
<pre><code class="language-console">source ./lib/misc.sh &amp;&amp; launch_k8s kube-00
source ./lib/misc.sh &amp;&amp; launch_vms virt-01
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p>Add locality info:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin patch workloadentries httpbin-192.168.65.5-vm-network --type merge -p '{"spec":{"locality":"milky-way/solar-system/virt-01"}}'
k --context pasta-1 -n httpbin patch deployment sleep --type merge -p '{"spec":{"template":{"metadata":{"labels":{"istio-locality":"milky-way.solar-system.pasta-1"}}}}}'
k --context pasta-1 -n httpbin label pod sleep-xxxx topology.istio.io/subzone=pasta-1 topology.kubernetes.io/region=milky-way topology.kubernetes.io/zone=solar-system
</code></pre>
<pre><code class="language-console">k --context pasta-1 -n httpbin patch deployment sleep --type merge -p '{"spec":{"template":{"metadata":{"labels":{
  "topology.kubernetes.io/region":"milky-way",
  "topology.kubernetes.io/zone":"solar-system",
  "topology.istio.io/subzone":"pasta-1"
}}}}}'
</code></pre>
<p>Delete locality info:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin patch workloadentries httpbin-192.168.65.5-vm-network --type json -p '[{"op": "remove", "path": "/spec/locality"}]'
k --context pasta-1 -n httpbin patch deployment sleep --type json -p '[{"op": "remove", "path": "/spec/template/metadata/labels/istio-locality"}]'
k --context pasta-1 -n httpbin label pod sleep-xxxx topology.istio.io/subzone- topology.kubernetes.io/region- topology.kubernetes.io/zone-
</code></pre>
<p>Set debug images:</p>
<pre><code class="language-console">k --context pasta-1 -n istio-system set image deployment/istiod-1-19-6 discovery=docker.io/h0tbird/pilot:1.19.6
k --context pasta-1 -n httpbin patch deployment sleep --type merge -p '{"spec":{"template":{"metadata":{"annotations":{"sidecar.istio.io/proxyImage":"docker.io/h0tbird/proxyv2:1.19.6"}}}}}'
</code></pre>
<p>Unset debug images:</p>
<pre><code class="language-console">k --context pasta-1 -n istio-system set image deployment/istiod-1-19-6 discovery=docker.io/istio/pilot:1.19.6
k --context pasta-1 -n httpbin patch deployment sleep --type merge -p '{"spec":{"template":{"metadata":{"annotations":{"sidecar.istio.io/proxyImage":"docker.io/istio/proxyv2:1.19.6"}}}}}'
</code></pre>
<p>Debug:</p>
<pre><code class="language-console">k --context pasta-1 -n httpbin exec -it deployments/sleep -c istio-proxy -- sudo bash -c 'echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope'
k --context pasta-1 -n istio-system exec -it deployments/istiod-1-19-6 -- dlv dap --listen=:40000 --log=true
k --context pasta-1 -n istio-system port-forward deployments/istiod-1-19-6 40000:40000
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
